% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/generate-grf-object.R
\name{generate.grf.object}
\alias{generate.grf.object}
\title{Create object used for generating realizations from an approximate GRF}
\usage{
generate.grf.object(x.lower = -1, x.upper = 1, y.lower = -1,
  y.upper = 1, resolution.x = 100, resolution.y = 100,
  range.parameter = 1, scale.parameter = 1, strength.parameter = 1,
  direction.parameter = 0, initial.seed = 0, params = NULL,
  num.realizations = NULL, realization.names = NULL)
}
\arguments{
\item{x.lower, x.upper, y.lower, y.upper}{Specifies the boundaries of the rectangular
region that the GRF is defined on.}

\item{resolution.x, resolution.y}{The number of grid cells used for the regular grid,
in the x- and y-direction, respectively.}

\item{range.parameter}{The range is a positive number. A small range gives realizations
that tend to have more variation over shorter distances, while a long range leads
to realizations that have less variation and appear smoother.}

\item{scale.parameter}{The scale is a positive number that controls the scale of the
realizations. Setting \code{scale.parameter = a} is equivalent to setting
\code{scale.parameter = 1} and then multiplying the realizations by \code{a}. In more technical terms, this is the marginal standard deviation of the GRF.}

\item{strength.parameter, direction.parameter}{These parameters are used to specify a range that depends on direction. If \code{strength.parameter = p} and \code{direction.parameter = theta}, then the range is \code{p} times longer along the direction given by \code{theta}, when compared to the range along the direction perpendicular to \code{theta}. \code{direction.parameter} is the angle formed with the x-axis measured in radians.}

\item{initial.seed}{The initial seed value used when generating realizations.}

\item{params}{Optional, a list containing all of the above parameters.}

\item{num.realizations}{The number of realizations to initialize the GRF object with.}

\item{realization.names}{The names of the realizations to initialize the GRF object with.}
}
\value{
A list containing:
\item{Q}{The precision matrix of the GRF approximation.}
\item{grid}{A \code{(resolution.x*resolution.y) x 2} matrix containing the center coordinates of the regular grid that the approximation is defined on.}
\item{initial.seed}{The initial seed value used when generating realizations.}
\item{params}{A list of the remaining input parameters listed above.}
}
\description{
Creates a list containing the elements necessary for doing essential computations with the GRF approximation.
}
\details{
If the GRF object is to be initialized with realizations, either \code{num.realizations} or \code{realization.names} must be specified.
}
\examples{
# Prepare GRF object
grf.object = generate.grf.object(0, 1, 0, 1, 25, 25,
                                 strength.parameter = 2,
                                 direction.parameter = pi/4,
                                 initial.seed = 1000)
# Add realization to object
grf.object = add.grf.realization(grf.object)
# Extract data frame containing the 25 x 25 grid coordinates and
# the value of the GRF in each grid cell.
original.df = get.realization.df(grf.object)
original.df$facet.var = "Original"
# Interpolate GRF on finer grid for comparison
interp.locations = generate.grid.centers(0, 1, 0, 1, 500, 500)
interp.values = evaluate.grf(interp.locations, grf.object, method = "linear")
interp.df = data.frame(x = interp.locations[, 1],
                       y = interp.locations[, 2],
                       z = interp.values)
interp.df$facet.var = "Interpolation"

library(ggplot2)
ggplot()+
  geom_raster(data = rbind(original.df, interp.df),
              aes(x = x, y = y, fill = z))+
  coord_fixed()+
  facet_grid(cols = vars(facet.var))

# Create and plot vector field, using the GRF to specify direction
vector.df = original.df
# Getting an angle that is between 0 and 2*pi
vector.df$theta = with(vector.df, 2*pi*(z - min(z))/(max(z) - min(z)))
vector.df$vx = 0.04*cos(vector.df$theta)
vector.df$vy = 0.04*sin(vector.df$theta)
ggplot()+
  geom_segment(data = vector.df, aes(x = x-vx/2, xend = x+vx/2,
                                     y = y-vy/2, yend = y+vy/2),
               arrow = arrow(length = unit(4, "pt")))+
  coord_fixed()

}
\author{
Mathias Isaksen
}
