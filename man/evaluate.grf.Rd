% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluate-grf.R
\name{evaluate.grf}
\alias{evaluate.grf}
\title{Evaluate the value of a GRF realization in specified locations}
\usage{
evaluate.grf(locations, grf.object, realization.number = 1,
  periodic = TRUE, method = "linear", smooth.func = NULL,
  rescale = FALSE)
}
\arguments{
\item{locations}{An N x 2 matrix containing the coordinates of the N locations of interest.}

\item{grf.object}{The GRF object containing the realization.}

\item{realization.number}{The index of the realization of interest.}

\item{periodic}{If true, locations outside the rectangular domain of \code{grf.object} are mapped to the corresponding point inside the domain. Otherwise, the locations are mapped to the nearest point on the boundary.}

\item{method}{Either \code{"nearest"} (which maps the location to the nearest grid cell), \code{"linear"} (which performs bilinear interpolation of the nearest four grid cells), or \code{"smooth"} (which is a smoothed version of bilinear interpolation, using the smoothstep as a weight function).}

\item{smooth.func}{If \code{method == "smooth"}, then \code{smooth.func} is an optional parameter specifying the function used for weighting the values in the nearest four grid cells. Should satisfy \code{smooth.func(0) = 0} and \code{smooth.func(1) = 1}.}

\item{rescale}{If true, a min-max scaling is applied to the interpolated values. This ensures that the values are between 0 and 1.}
}
\value{
A \code{numeric} of length N containing the interpolated values of the GRF in the specified locations.
}
\description{
Evaluate the value of a GRF realization in specified locations
}
\note{
In its current state, \code{method = "smooth"} seems to have some artifacts visible at high resolutions. Therefore, it should be used with caution.
}
\examples{
# Prepare GRF object
grf.object = generate.grf.object(0, 1, 0, 1, 25, 25,
                                 strength.parameter = 2,
                                 direction.parameter = pi/4,
                                 initial.seed = 1000)
# Add realization to object
grf.object = add.grf.realization(grf.object)
# Extract data frame containing the 50 x 50 grid coordinates and
# the value of the GRF in each grid cell.
original.df = get.realization.df(grf.object)
original.df$facet.var = "Original"
# Interpolate GRF on finer grid for comparison
interp.locations = generate.grid.centers(0, 1, 0, 1, 500, 500)
interp.values = evaluate.grf(interp.locations, grf.object, method = "linear")
interp.df = data.frame(x = interp.locations[, 1],
                       y = interp.locations[, 2],
                       z = interp.values)
interp.df$facet.var = "Interpolation"

library(ggplot2)
ggplot()+
  geom_raster(data = rbind(original.df, interp.df),
              aes(x = x, y = y, fill = z))+
  coord_fixed()+
  facet_grid(cols = vars(facet.var))


}
\author{
Mathias Isaksen
}
